package impro.googlemap{	import flash.events.*; 		public class TouchEventsManager extends EventDispatcher 	{				private var mActiveEvents : Array;		private static var mInstance : TouchEventsManager;		private static var allowInst : Boolean = false;		private static var touchEvent:TouchEvent;				public function TouchEventsManager()		{			if (!allowInst) {	            throw new Error("Error: Instantiation failed: Use TouchEventsManager.getInstance() instead of new.");	          }	          else	          {	          	mActiveEvents = new Array();	          }					}					public static function getInstance():TouchEventsManager		{						if (mInstance == null)			{            	allowInst = true;				mInstance = new TouchEventsManager();				allowInst = false;				}			return mInstance;					}			/*********************************************************************************************	 * public 	 *********************************************************************************************/			public function eventInUse (e : TouchEvent) : Boolean		{			var i : uint;			var len : uint = mActiveEvents.length;						for (i = 0; i < len; i++)			{				if (mActiveEvents[i].id == e.ID)				{					return true;				}			}			return false;		}				public function addActiveEvent (e : TouchEvent, source:Object = null) : void		{// 			if (source is TappableMap)			{//				//when it rolls over another object that is above it it will try to add it again.//				//this stops the conflict				var i : uint;				var len : uint = mActiveEvents.length;//								for (i = 0; i < len; i++)				{					if (mActiveEvents[i].id == e.ID)					{//						//now we need to tell the last object to render a mouseUp...						if (mActiveEvents[i].currentTarget != e.currentTarget)						{//							if (mActiveEvents[i].currentTarget is TappableMap)//							{//								mActiveEvents[i].currentTarget.mouseUp(e);//							}														//set the target where to render a mouse up at the end of the touch							if(source == null){								mActiveEvents[i].currentTarget = e.currentTarget;							}else{								mActiveEvents[i].currentTarget = source;							}						}												return;					}				}												var obj : Object = new Object();				obj.id = e.ID;				if(source == null){					obj.currentTarget = e.currentTarget;				}else{					obj.currentTarget = source;				}				mActiveEvents.push(obj);			}								}				public function endActiveEvent (e : TouchEvent) : Number		{			//			trace("endActiveEvent - e.ID = " + e.ID);						var useCount : Number = 0;			var selID : Number = -1;			var i : uint;			var len : uint = mActiveEvents.length;						for (i = 0; i < len; i++)			{				if (e.ID == mActiveEvents[i].id)				{					selID = i;					}							}			if (selID > -1)			{				var selTarget : Object = mActiveEvents[selID].currentTarget;								for (i = 0; i < len; i++)				{					if (selTarget == mActiveEvents[i].currentTarget)					{						useCount++;						}				}								if (useCount == 1)				{										if (selTarget is TappableMap)					{//						selTarget.mouseUp(e);					}									}				mActiveEvents.splice(selID, 1);			}			return selID;		}				public function getActiveEvents(target:Object):Array{			var eventArrayTemp:Array = new Array();			for each(var eventTemp:Object in mActiveEvents){				var tuioobj : TUIOObject = TUIO.getObjectById(eventTemp.id);				if(tuioobj){					if(eventTemp.currentTarget == target){						eventArrayTemp.push(eventTemp);					}				}else{					try{						touchEvent = new TouchEvent(TouchEvent.MOUSE_UP);						touchEvent.ID = eventTemp.id;						endActiveEvent(touchEvent);					}catch(e:Error){						trace(this, "error when trying to remove obsolete element: ",e.message);					}				}			}			return eventArrayTemp;		}	}}